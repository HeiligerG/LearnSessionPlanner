# Database Configuration
# PostgreSQL connection string
# Format: postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
# Change user, password, host, port, and database name for your environment
# In Docker, use service name as host (e.g., postgres:5432)
DATABASE_URL="postgresql://user:password@localhost:5432/learn_session_planner?schema=public"

# Application Configuration
# API server port
PORT=4000

# Environment (development, production, test)
NODE_ENV=development

# CORS Configuration
# Allowed frontend origin (comma-separated list for multiple origins)
CORS_ORIGIN=http://localhost:3000

# JWT Configuration
# JWT access token secret - CHANGE THIS IN PRODUCTION!
# Generate with: openssl rand -base64 32
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production

# Access token expiration (e.g., 15m, 5m, 3600s)
JWT_EXPIRES_IN=15m

# JWT refresh token secret - CHANGE THIS IN PRODUCTION!
# Generate with: openssl rand -base64 32
JWT_REFRESH_SECRET=your-super-secret-refresh-key-change-this-in-production

# Refresh token expiration (e.g., 7d, 14d, 30d)
JWT_REFRESH_EXPIRES_IN=7d

# CSRF Configuration
# CSRF token secret - CHANGE THIS IN PRODUCTION!
# Generate with: openssl rand -base64 32
CSRF_SECRET=your-super-secret-csrf-key-change-this-in-production

# Rate Limiting Configuration
# Time window in milliseconds (60000 = 1 minute)
THROTTLE_TTL=60000

# Maximum number of requests per time window
THROTTLE_LIMIT=100

# Instructions:
# 1. Copy this file to .env: cp .env.example .env
# 2. Update DATABASE_URL with your local PostgreSQL credentials
# 3. Generate a secure JWT_SECRET: openssl rand -base64 32
# 4. Never commit .env to version control
# 5. In production, use environment variables or secret management
#    (Docker secrets, Kubernetes secrets, AWS Secrets Manager, etc.)
